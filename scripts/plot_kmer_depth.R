#!/usr/bin/env Rscript
# ##############################################################################
#  Author:   Hector Fabio Espitia-Navarro
#            Georgia Institute of Technology
#  Version:  1.0
#  Date:     01/19/2019
# ##############################################################################

# Install required packages -----------------------------------------------
personal.lib.path <- Sys.getenv("R_LIBS_USER")
if(!file.exists(personal.lib.path))                                                                                    
  dir.create(personal.lib.path)

printMessage <- function(message, verbose){
  if(verbose)
    cat(message)
}

# crayon::bold("Hola")
installAndLoadPackages <- function(pkg, verbose){
  printMessage("Please wait a moment! Checking for the following required packages:\n", verbose)
  lapply(pkg, function(x){printMessage(paste0(" ", x,"\n"), verbose)})
  printMessage("Done!\n", verbose)
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) {
    printMessage("Installing new packages... ", verbose)
    install.packages(new.pkg, dependencies = TRUE,
                     repos="http://cran.rstudio.com/",
                     lib = personal.lib.path)
    printMessage("Done!\n", verbose)
  }
  printMessage("Loading required packages... ", verbose)
  sapply(pkg, function(x){
    suppressPackageStartupMessages(require(x, character.only = TRUE, quietly = TRUE))
  })
  printMessage("Done!\n", verbose)
}
# github.related.packages <- c("devtools", "Rcpp")
# packages <- c("argparser", "tidyverse", "RColorBrewer", "ggsci", "stringr", "svglite")
packages <- c("tidyverse", "RColorBrewer", "ggsci", "stringr", "svglite", "gridExtra")
# installAndLoadPackages(packages, verbose = TRUE)
installAndLoadPackages("argparser", verbose = FALSE)

# Command line arguments processing ---------------------------------------
# Get script name
initial.options <- commandArgs(trailingOnly = FALSE)
script.name     <- basename(sub("--file=", "", initial.options[grep("--file=", initial.options)]))
# Process command line arguments
# Create a parser
p <- arg_parser("This script generates k-mer depth plots using a depth file generated by the \033[1mSTing typer\033[22m tool (-t option).",
                name = script.name)
# Add Positional arguments (required)
p <- add_argument(p, "input_file", help = "Samples file. Text file with a list of sample names (line by line).")
# Add options
p <- add_argument(p, "--gene_file", help = "Path to a text file with a list of genes/loci to be plotted.")
p <- add_argument(p, "--prefix", help = "Filename prefix for output files.", 
                  default = "kmer_depth")
p <- add_argument(p, "--sample_name", help = "Sample name.", 
                  default = "input file's name")
p <- add_argument(p, "--max_loci_per_page", help = "Maximum number of loci to print on each page.", 
                  default = 7)
p <- add_argument(p, "--format", help = "Output file format. Valid options are 'pdf', 'png', and 'svg'", 
                  default = "pdf")
# Initialization of variables ---------------------------------------------
# Values to test the script using RStudio
script.home       <- "/home/hspitia/projects/sting"
# inputFile         <- paste(script.home, "ERR036060.depth.2.tsv", sep = "/")
# geneFile          <- paste(script.home, "rmlst_failed_loci.txt", sep = "/")
inputFile         <- paste(script.home, "depth.tsv", sep = "/")
geneFile          <- paste(script.home, "loci.txt", sep = "/")
out.prefix        <- "kmer_ext_depth"
sample.name       <- basename(inputFile)
max.loci.per.page <- 7
out.format        <- "pdf"
# Parse command line arguments
command.line = TRUE  # Turn to FALSE to test the script inside RStudio
argv <- list()
if(command.line) {
  argv <- parse_args(p)
} else {
  argv <- parse_args(p, list(inputFile, 
                             "--gene_file", geneFile,
                             "--prefix", out.prefix,
                             "--sample_name", sample.name,
                             "--max_loci_per_page", max.loci.per.page,
                             "--format", out.format))
}
# Get argument values from the command line
input.file        <- argv$input_file
gene.file         <- argv$gene_file
out.format        <- argv$format
out.prefix        <- argv$prefix
max.loci.per.page <- argv$max_loci_per_page
sample.name       <- argv$sample_name
# if (sample.name == "")
if (sample.name == "input file's name")
  sample.name <- basename(input.file)

# Function to check if file exists ----------------------------------------
CheckFileExists <- function(file.list) {
  non.exist.files <- !file.exists(file.list)
  if(any(non.exist.files)) {
    sprintf("\n  The file \"%s\" does not exist.", file.list[non.exist.files])
  }
}
# Check for input files ---------------------------------------------------
files.to.check <- c(input.file)
error.message  <- CheckFileExists(files.to.check)

if(!is.null(error.message)){
  stop(error.message)
} else {
  # Code core - Begin -------------------------------------------------------
  installAndLoadPackages(packages, verbose = TRUE)
  # FUNCTIONS:
  # Function to dark a list of colors ---------------------------------------
  darkColors <- function(palette, level){
    rgbColors <- as.data.frame(t(as.data.frame(lapply(as.data.frame(t(col2rgb(palette))), 
                                                      function(x) { round(x * level)}))))
    unname(sapply(rgbColors, function(x){ rgb(x[1], x[2], x[3], maxColorValue=255) }))
  }
  # Function for plotting k-mer depth ----------------------------------------
  plotDepth <- function(dataToPlot, labelsData, fillColors, borderColors) {
    max.x       <- max(dataToPlot$Position)
    max.y       <- max(dataToPlot$kmerDepth)
    x.limits    <- seq(0, max.x, 100)
    y.limits    <- seq(0, max.y, 20)
    nTopAlleles <- length(unique(dataToPlot$N))
    
    d.plot <- ggplot(data = dataToPlot, aes(x = Position, y = kmerDepth),
                     size = 0.2) +
      geom_vline(aes(xintercept = Length), size = 0.5, color = "#a5a5a5") +
      geom_area(size = 0.4, alpha = 0.6, aes(color = Locus, fill = Locus)) +
      # geom_area(alpha = 0.6, aes(color = Allele, fill = Allele)) +
      # scale_color_manual(values = getPalette) +
      scale_color_manual(values = borderColors) +
      scale_fill_manual(values = fillColors) +
      geom_text(data = labelsData,
                # aes(x = Length, y = max.y*0.98, group = Locus, hjust = 1,
                # aes(x = Length, y = info.y * 1.09, group = Locus, hjust = 1,
                aes(x = Length, y = info.y * 0.5, group = Locus,
                    hjust = 0,
                    label = str_glue("{format(round(Length, 1), nsmall = 0, big.mark = ',')}")),
                show.legend = F, color = "#a5a5a5", size = 3, angle = 90,
                nudge_x = -(max.x*0.025)
      ) +
      geom_label(data = labelsData, aes(x = name.x, y = name.y, label = Allele), fill = panelColor,
                 alpha = 0.5, label.size = 0, label.padding = unit(1, "mm"), label.r = unit(1, "mm"),
      # geom_text(data = labelsData, aes(x = name.x, y = name.y, label = Allele),
                size = annotTextSize * 1.05, color = "#333333") +
      geom_text(data = labelsData,
                parse = TRUE,
                aes(x = info.x, y = info.y,
                    label = paste0("{{{italic(hat(f)[k]) ==", format(round(NormKmerCount, 2), nsmall = 2),
                                  "*~~~italic(c)} ==", format(round(cov, 2), nsmall = 2), "*'%'",
                                  "*~~~sigma} ==", format(round(sd, 2), nsmall = 2),
                                  "~~~bar(italic(d))} ==", format(round(meanDepth, 2), nsmall = 2))),
                hjust = "left", vjust = 1, size = annotTextSize * 0.8, color = "#222222") +
      facet_grid(Locus ~ N, scales = "free_y") +
      # scale_x_discrete(limits = x.limits, expand = c(0, 2.0)) +
      scale_x_discrete(limits = x.limits, expand = c(0.006, 2.0)) +
      theme_bw() +
      plotTheme +
      labs(title    = expression(italic("k")*"-mer Depth Distribution"),
           subtitle = paste("Top", nTopAlleles, "alleles/genes on sample", sample.name),
           x        = "Position along sequence (bp)",
           y        = expression(paste(italic(k), "-mer depth")),
           # caption  = "cov: coverage; ad: average depth; sd: standard deviation")
           caption  = expression(paste(italic(hat(f)[k]),": norm. ", italic("k"), "-mer freq.;  ",
                                       italic("c"),": coverage;  ", 
                                       italic(sigma), ": standard deviation;  ",
                                       italic(bar(d)), ": average depth"), sep = "")
           )
    return(d.plot)
  }
  # (depth.plot   <- plotDepth(data.to.plot, labelsData, fillPalette, borderPalette))
  # Function for plotting k-mer depth distributions as box plots ------------
  plotDepthDist <- function(data.to.plot, labelsData, fillColors, borderColors){
    dist.plot <- ggplot(data.to.plot, aes(x = AlPos, y = kmerDepth)) +
      geom_jitter(position = position_jitter(width=.3), aes(color = Locus),
                  alpha = 0.4, size = 1.2, shape = 16) +
      geom_boxplot(alpha = 0.7, size = 0.5, aes(fill = Locus, color = Locus)) +
      geom_text(data = labelsData, size = 4, hjust = "center",
                aes(x = N,#(N - 0.5), 
                    y = info.y * 1.05, 
                    label = Allele),
                color = "#333333") +
      geom_text(data = labelsData, size = 3, hjust = "center",
                parse = TRUE,
                aes(x = N,#(N - 0.4), 
                    # y = info.y * 0.08,
                    y = info.y * 0.96,
                    label = paste0("sigma ==",format(round(sd, 1), nsmall = 1))),
                color = "#333333") +
      geom_point(data = labelsData,
                 shape = 23, fill = "white",
                 aes(x = N, y = meanDepth)) +
      facet_grid(Locus ~ ., scales = "free_y") +
      scale_color_manual(values = borderColors) +
      scale_fill_manual(values = fillColors) +
      labs(title = expression(paste(italic("k"), "-mer depth distribution")),
           subtitle = basename(input.file),
           x        = "Allele Ranking",
           y        = expression(paste(italic(k), "-mer depth")),
           caption  = expression(paste(italic(sigma), ": standard deviation")))+#,"sd: standard deviation") +
      theme_bw() +
      plotTheme +
      theme(axis.text.x   = element_text(angle = 0, size = axisTextSize,
                                         vjust = 1, hjust = 0.5, color = textColor))
    return(dist.plot)
  }
  # Function to get data for annotations ------------------------------------
  getLabelsData <- function(data.to.plot) {
    max.x <- max(data.to.plot$Position)
    max.y <- max(data.to.plot$kmerDepth)
    
    nLoci    <- length(unique(data.to.plot$Locus))
    nAlleles <- length(unique(data.to.plot$N))
    
    alleles     <- unique(data.to.plot$Allele)
    loci        <- as.character(unique(data.to.plot$Locus))
    lociLabels  <- c()
    name.x      <- c()
    name.y      <- c()
    info.x      <- c()
    info.y      <- c()
    covs        <- c()
    avgDepths   <- c()
    meanDepth.x <- c()
    meanDepth.y <- c()
    for (i in loci) {
      lociLabels <- c(lociLabels, rep(i, nAlleles))
    }
    for (allele in alleles) {
      locus     <- as.character(unique(data.to.plot[data.to.plot$Allele == allele, "Locus"]))
      maxPos    <- max(data.to.plot[data.to.plot$Locus == locus, "Position"])
      maxDepth  <- max(data.to.plot[data.to.plot$Locus == locus, "kmerDepth"])
      name.x    <- c(name.x, (max.x / 2))
      name.y    <- c(name.y, (maxDepth * 0.25))
      info.x    <- c(info.x, max.x * 0.02)
      info.y    <- c(info.y, maxDepth * 1.5)
      covs      <- as.numeric(c(covs, unique(data.to.plot[data.to.plot$Allele == allele, "Coverage"])))
      avgDepths <- as.numeric(c(avgDepths, unique(data.to.plot[data.to.plot$Allele == allele, "AverageKmerDepth"])))
    }
    labelsData <- data.frame(Allele = alleles,
                             name.x = name.x,
                             name.y = name.y,
                             info.x = info.x, 
                             info.y = info.y,
                             meanDepth = avgDepths,
                             N = rep(unique(data.to.plot$N), nLoci),
                             Locus = lociLabels,
                             cov = covs
                             ) %>%
      left_join(data.to.plot %>%
                  group_by(Allele, Length, NormKmerCount, Score) %>%
                  summarise(sd = sd(kmerDepth)),
                by = c("Allele" = "Allele"))
    labelsData
  }
  
  # Check for genes/loci file to filter loci to plot  -----------------------
  loci.to.plot <- c()
  # if (!is.null(gene.file)|| gene.file != "") {
  if (!is.null(gene.file) && !is.na(gene.file) && gene.file != "") {
    error.message <- CheckFileExists(gene.file)
    if (!is.null(error.message)){
      cat("Warning:")
      cat(error.message)
      cat("  The plotting process will continue without filtering genes/loci.\n")
    } else {
      loci.to.plot <- scan(gene.file, character(), quiet = TRUE)
    }
  }
  
  # Data processing and plotting --------------------------------------------
  cat("Plotting depths... ")
  options(stringsAsFactors = T, readr.num_columns = 0)
  # Load data
  inData <- read_tsv(input.file)
  # inData <- read.delim(input.file)
  colnames(inData) <- c("N", "Locus", "Allele", "Position", "kmerDepth",
                        "NormKmerCount", "Coverage", "Score", "AverageKmerDepth")
  # Transform data
  data.to.plot <- inData %>%
    left_join(inData %>% 
                group_by(Allele) %>% 
                summarise(Length = n()), by = "Allele") %>% 
    arrange(Locus, N) %>% 
    mutate(
      AlPos = factor(N, levels = unique(.$N)),
      Allele = factor(Allele, levels = unique(inData$Allele)))  
  # Filtering loci/genes from genes_file input param 
  if (length(loci.to.plot) > 0) {
    data.to.plot <- data.to.plot %>% 
      filter(Locus %in% loci.to.plot)
  }
  longestLocusNameLength <- max(str_length(as.character(unique(inData$Locus))))
  nLoci    <- length(unique(data.to.plot$Locus))
  nAlleles <- length(unique(data.to.plot$N))
  
  # Theme-related variable definition ---------------------------------------
  annotLinetype     <- "solid"
  annotTextSize     <- 4
  axisColor         <- "#000000"
  axisTextSize      <- 12
  barAnnotTextSize  <- 4
  baseTextSize      <- 14
  gridColor         <- "#e0e0e0"
  lineSize          <- 0.3
  # panelColor        <- "#ffffff"
  # panelColor        <- "#fff4e0"
  panelColor        <- "#f2efe6"
  # stripBackground   <- "#cccccc"
  stripTextSize     <- axisTextSize
  if (longestLocusNameLength > 12)
    stripTextSize  <- stripTextSize * 0.6
  textColor  <- "#000000"
  # baseFontFamily        <- "Arial"
  
  # Custom theme definition for plots ---------------------------------------
  plotTheme <- list(
    theme(
      axis.text.x      = element_text(angle = 50, size = axisTextSize,
                                      vjust = 1, hjust = 1, color = textColor),
      axis.text.y      = element_text(size = axisTextSize, color = textColor),
      axis.ticks       = element_line(size = lineSize),
      axis.title.x     = element_text(margin = margin(6,0,8,0, "mm")),
      axis.title.y     = element_text(margin = margin(0,6,0,0, "mm")),
      legend.position  = "none",
      panel.border     = element_rect(size = lineSize),
      panel.background = element_rect(fill = panelColor),
      panel.grid       = element_line(size = lineSize, colour = gridColor),
      panel.grid.minor = element_blank(),
      plot.margin      = margin(10,10,0,10, "mm"),
      panel.spacing    = unit(4, "mm"),
      plot.caption     = element_text(size = baseTextSize * 0.7, face = "italic"),
      plot.title       = element_text(hjust = 0.5),
      plot.subtitle    = element_text(hjust = 0.5),
      strip.background = element_rect(size = lineSize),
      strip.text       = element_text(size = stripTextSize),
      text             = element_text(size = baseTextSize)
    )
  )
  
  # Palette definition ------------------------------------------------------
  # colourCount <- length(unique(inData$Locus))
  rowsPerPage <- ifelse(nLoci > max.loci.per.page, max.loci.per.page, nLoci)
  # colourCount <- nLoci
  colourCount <- rowsPerPage
  # colourCount  <- length(unique(data.to.plot$Allele))
  # fillPalette  <- colorRampPalette(brewer.pal(8, "Dark2"))(colourCount)
  # fillPalette  <- colorRampPalette(brewer.pal(12, "Paired"))(colourCount)
  # fillPalette  <- colorRampPalette(brewer.pal(9, "Set1"))(colourCount)
  # fillPalette  <- colorRampPalette(pal_npg("nrc")(10))(colourCount)
  # fillPalette  <- colorRampPalette(pal_d3("category20")(20))(colourCount)
  fillPalette   <- colorRampPalette(pal_nejm("default")(8))(colourCount)
  # fillPalette   <- c("#93a9a5", colorRampPalette(pal_nejm("default")(8))(colourCount))
  borderPalette <- darkColors(fillPalette, 0.6)
  # library("scales"); show_col(fillPalette); show_col(borderPalette)
  
  # Depth plot -------------------------------------------------------------
  # lociPerPage    <- 3
  wFactor        <- 5.8
  plotTitlesSize <- 2.39
  
  getPlotHeight <- function(rows, extras){
  	hFactor <- ifelse(rows == 1, 1.88, 1.6)
  	# loci + titles and foot note + strip + space between locus
  	(rows*hFactor) + extras + ((rows-1)*0.157) #in
  }
  
  # rowsPerPage <- ifelse(nLoci > max.loci.per.page, max.loci.per.page, nLoci)
  height      <- getPlotHeight(rowsPerPage, plotTitlesSize)
  width       <- nAlleles * wFactor
  loci        <- unique(data.to.plot$Locus)
  sets        <- split(loci, ceiling(seq_along(loci)/rowsPerPage))
  
  plots <- lapply(sets, function(set, dp=data.to.plot, rp=rowsPerPage){
  	nLoci        <- length(set)
  	subsetToPlot <- dp %>% filter(Locus %in% set)
  	# subPalette   <- 
  	ld           <- getLabelsData(subsetToPlot)
  	p            <- plotDepth(subsetToPlot, ld, fillPalette, borderPalette)
  	if(nLoci < rp){
  		hlay    <- matrix(c(1, NA))
  		total   <- getPlotHeight(rp, plotTitlesSize)
  		cHeight <- getPlotHeight(nLoci, plotTitlesSize)
  		blank   <- getPlotHeight(rp-nLoci, 0)
  		heights <- matrix(c(cHeight/total, blank/total))
  		p       <- grid.arrange(p, layout_matrix = hlay, heights = heights)
  	}
  	return(p)
  })
  
  if (out.format == "pdf") {
  	out.filename <- paste(out.prefix, out.format, sep = ".")
  	ml <- marrangeGrob(plots, nrow=1, ncol=1, padding = unit(10, "mm"),
  										 top = NULL, bottom = quote(paste("Page", g, "of", npages)))
  	ggsave(filename = out.filename, plot = ml,
  				 width  = width, height = height, dpi = 400, limitsize = FALSE)
  }
  else {
  	for (i in seq_along(plots)) {
  		out.filename <- paste(out.prefix, sprintf("%03d", i), out.format, sep = ".")
  		ggsave(filename = out.filename, plot = plots[[i]],
  					 width  = width, height = height, dpi = 400, limitsize = FALSE)
  	}
  }
  
  # # Depth distribution plot ------------------------------------------------
  # hFactor  <- 3
  # wFactor  <- 2
  # if (nLoci == 1)
  #   hFactor <- 3.5
  # height       <- nLoci * hFactor
  # width        <- nAlleles * wFactor
  # # Generate plot
  # (dist.plot <- plotDepthDist(data.to.plot, labelsData, fillPalette, borderPalette))
  # # Save plot
  # out.filename <- paste0(out.prefix, "_dist.", out.format)
  # if (out.format == "png") {
  #   ggsave(filename = out.filename, plot = dist.plot,
  #          width  = width, height = height, type = "cairo-png", dpi = 300)
  # } else {
  #   ggsave(filename = out.filename, plot = dist.plot,
  #          width  = width, height = height, dpi = 400)
  # }
  
  cat("Done! \n")

  # Code core - End ---------------------------------------------------------
}
